#!/usr/bin/env python

from __future__ import annotations

import numpy
import itertools
import os
import os.path as path
import subprocess
import re
import argparse
from typing import List, Tuple, Dict


class Placeholder:
    """ Represents substitutable place in a template. Stores a list of values that are to be substituted into that place """
    def __init__(self, data: str, template_dir: str = None):
        params = Placeholder.parse_params(data)
        self.name = params["name"]
        # data can be generated by using range
        if "range" in params:
            self.data_source = "range"
            self.data = []
            areas = params["range"].split("+")
            areas = map(lambda x: eval(x), areas)
            for area in areas:
                self.data += list(numpy.arange(area[0], area[1] + area[2] / 10, area[2]))
        # or read from a line in a file
        elif "file" in params:
            self.data_source = "file"
            file_name = params["file"]
            file_path = path.join(template_dir, file_name)
            with open(file_path, "r") as file:
                lines = file.readlines()
            line_num = int(params["line"])
            values_str = lines[line_num - 1].split(";")
            if values_str[-1] == "\n":
                values_str = values_str[:-1]
            self.data = list(map(float, values_str))
        else:
            raise Exception('Placeholder data is not provided')

    def __iter__(self):
        return iter(self.data)

    def __str__(self):
        return "Name: {0}; data {1}".format(self.name, self.data)

    @staticmethod
    def parse_params(data: str) -> Dict[str, str]:
        """ Parses a string description of a placeholder and returns dict with all params """
        lexemes = data.split("|")
        keys_values = map(lambda x: x.split("="), lexemes)
        iteration_params = {}
        for iteration_token in keys_values:
            key = iteration_token[0].strip()
            value = iteration_token[1].strip()
            iteration_params[key] = value
        return iteration_params


class ScriptManager:
    """ Generates and submits multiple molpro jobs described via job templates """
    # creates a file with this name
    input_name = "input.inp"
    # looks for a file with this name when requesting results collection
    output_name = "input.out"
    # checks a file with this name for any unsubmitted jobs from the last launch (due to queue overflow)
    queue_file_path = "queue"
    # Controls how many jobs can be sent at once
    queue_limit = 5000

    def __init__(self, template_path: str):
        # Path to template file describing what jobs need to be generated
        self.template_path = template_path
        self.template_dir = path.dirname(self.template_path)
        # Controls how placeholders should be combined. If true, i-th value of a placeholder combines only with i-th values of other
        # placeholders. If false, each value of a placeholder combines with each value of all the other placeholders.
        self.additive_mode = False
        # Controls whether the file structure should be tree-like or flat (with folder names concatenated from names in each branch
        self.flat_structure = False
        # Defines if indexes should be used instead of names to create input paths
        self.index_naming = False

    @staticmethod
    def submit_input(input_path: str, submit_command: str):
        subprocess.call(submit_command.format(input_path), shell=True)
        print("{0} is submitted".format(input_path))

    @staticmethod
    def submit_inputs(input_folder_paths: List[str], submit_command: str):
        already_running = int(subprocess.check_output("q | wc -l", shell=True)) - 1
        for i in range(min(len(input_folder_paths), ScriptManager.queue_limit - already_running)):
            input_folder_path = input_folder_paths[i]
            input_file_path = input_folder_path + ScriptManager.input_name
            ScriptManager.submit_input(input_file_path, submit_command)
        ScriptManager.save_remaining_jobs(input_folder_paths, max(ScriptManager.queue_limit - already_running, 0))

    @staticmethod
    def save_remaining_jobs(input_folder_paths: List[str], starting_from: int):
        if starting_from < len(input_folder_paths):
            with open(ScriptManager.queue_file_path, "w") as queue_file:
                for i in range(starting_from, len(input_folder_paths)):
                    queue_file.write(input_folder_paths[i] + "\n")

    @staticmethod
    def generate_input(input_folder_path: str, content: str, value_set: List[float]):
        """ Generates an input file by replacing placeholders in content with value_set """
        os.makedirs(input_folder_path, exist_ok=True)
        input_file_name = input_folder_path + ScriptManager.input_name
        with open(input_file_name, "w") as input_file:
            input_file.write(content.format(*value_set))

    @staticmethod
    def collect_results(output_folder: str, key: List[float], collector: Dict[List[float], float], result_regexp: str,
                        submit_command: str = None) -> int:
        """ Reads output file (specified in ScriptManger) in output_folder, finds the result using result_regexp and stores it in collector
        under key (set of values for this file). If submit command is specified resubmits files on failure (cannot find the result)."""
        return_code = 0
        output_path = output_folder + ScriptManager.output_name
        try:
            with open(output_path) as output_file:
                content = output_file.read()
                match = re.findall(result_regexp, content, re.S)
                if len(match) == 1:
                    collector[key] = float(match[0])
                    return return_code
                if len(match) < 1:
                    print("Failed to find energy for point {0}".format(key))
                else:
                    print("Too many results found for point {0}".format(key))
        except FileNotFoundError:
            print("Failed to find output file for point {0}".format(key))
        return_code = 1
        if submit_command is not None:
            ScriptManager.submit_input(output_folder + ScriptManager.input_name, submit_command)
        return return_code

    @staticmethod
    def print_results(collector: Dict[List[float], float], key_names: List[str], out_file_path: str):
        field_width = 20
        key_digits = 5
        energy_digits = 16
        with open(out_file_path, "w") as out_file:
            for key_name in key_names:
                out_file.write("{0:<{1}}".format(key_name, field_width))
            for key in sorted(collector):
                out_file.write("\n")
                for item in key:
                    out_file.write("{0:<#{1}.{2}g}".format(item, field_width, key_digits))
                out_file.write("{0:<#{1}.{2}g}".format(collector[key], field_width, energy_digits))

    def process_template(self, collector: Dict[List[float], float] = None, result_regexp: str = None,
                         submit_command: str = None) -> Tuple[List[str], List[Placeholder]]:
        """ reads template, generates substituents set, generates input files. If collector is specified, collects results
        :return list of generated paths, list of placeholders"""
        with open(self.template_path) as template_file:
            content = template_file.read()
        content, placeholders = self.preprocess_template(content)

        if len(placeholders) == 0:
            raise Exception('Failed to find placeholders in the specified template')

        if self.additive_mode:
            substituents = list(zip(*[x.data for x in placeholders]))  # type: List[List[float]]
        else:
            substituents = list(itertools.product(*[x.data for x in placeholders]))  # type: List[List[float]]
        print("Generated {0} combinations".format(len(substituents)))
        input_paths = []
        total_failed = 0
        placeholder_names = [x.name for x in placeholders]
        for i in range(len(substituents)):
            value_set = substituents[i]
            next_folder_path = self.generate_input_folder_path(placeholder_names, value_set, i)
            input_paths.append(next_folder_path)
            ScriptManager.generate_input(next_folder_path, content, value_set)
            # in collecting mode
            if collector is not None:
                total_failed += ScriptManager.collect_results(next_folder_path, value_set, collector, result_regexp, submit_command)
        print("Total failed {0} out of {1}".format(total_failed, len(substituents)))
        return input_paths, placeholders

    def generate_input_folder_path(self, value_names: List[str], value_set: List[float], set_index: int) -> str:
        """ generates folder path for the next input file based on placeholder names and current value set
         placeholders should be in the same order as values (each value corresponds to a placeholder)
         :param value_names: List of names for each parameter in value_set
         :param value_set: List of values for variable job parameters. Used to generate unique path for each set of parameters
         :param set_index: A number used to label calculation folder when index naming is used"""
        if self.index_naming:
            return self.template_dir + "/" + str(set_index) + "/"
        answer = self.template_dir
        for i in range(len(value_names)):
            value_name = value_names[i]
            value_repr = "{0:.2f}".format(value_set[i]).rstrip("0").rstrip(".")
            if self.flat_structure:
                answer = answer + "{0}={1},".format(value_name, value_repr)
            else:
                answer = answer + "{0}/{1}/".format(value_name, value_repr)
        answer = answer[:-1] + "/"  # replace last symbol with slash
        return answer

    # parses the file, creates placeholder objects, marks the places where they are to be inserted
    def preprocess_template(self, content: str) -> Tuple[str, List[Placeholder]]:
        # temporarily replace original brackets since we need to use the same notation for substitution
        content = content.replace("{", "{{")
        content = content.replace("}", "}}")
        open_pattern = "(("
        close_pattern = "))"
        placeholders = []
        start = content.find(open_pattern)
        while start >= 0:
            end = content.index(close_pattern, start + 1)
            placeholders.append(Placeholder(content[start + len(open_pattern):end], self.template_dir))

            # File specification implies additive mode
            if placeholders[-1].data_source == "file":
                self.additive_mode = True

            # inserts {x} for placeholder number x at the place where it has to be inserted
            content = content[:start] + "{" + str(len(placeholders) - 1) + "}" + content[end + len(close_pattern):]
            start = content.find(open_pattern, start + 1)
        return content, placeholders


def parse_command_line_args() -> argparse.Namespace:
    parser = argparse.ArgumentParser(description="Submits range of points for PES calculations")
    parser.add_argument("template_path", help="Path to template file used to generate molpro jobs")
    parser.add_argument("-cp", "--collect-path",
                        help="Path to output file where the job results are to be written. Also switches to collect mode")
    parser.add_argument("-c", "--collect", action="store_true", help="Switch to collect mode")
    parser.add_argument("-rf", "--resubmit-failed", action="store_true", help="Automatically resubmits job is result is not found")
    parser.add_argument("-ri", "--regex-id", type=int, choices={0, 1}, default=0, help="Select regex used to find result")
    parser.add_argument("-q", "--qos", default="regular", help="Quality of Service")

    args = parser.parse_args()
    resolve_defaults(args)
    return args


def resolve_defaults(args: argparse.Namespace):
    if args.resubmit_failed:
        args.collect = True
    if args.collect_path is None and args.collect:
        args.collect_path = args.template_path + ".out"


def select_result_regex(regex_id: int) -> str:
    # relaxed davidson without orbital relaxation is chosen because it is a default value picked as mrci energy by molrpo
    # see: https://www.molpro.net/info/2015.1/doc/manual/node320.html
    if regex_id == 0:
        return r"RESULTS FOR STATE 1.1.+?without orbital relaxation.+?fixed reference.+?energies\s+(.+?)\s\(Davidson, relaxed"
    elif regex_id == 1:
        return r"!CCSD\(T\)-F12a total energy\s+(.*?)\n"


def main():
    # set script parameters, see also ScriptManager for extra parameters
    args = parse_command_line_args()
    result_regex = select_result_regex(args.regex_id)
    submit_command = "sub_molpro {0} -t 24 --no-queue" + " -q " + args.qos
    resubmit_failed = args.resubmit_failed
    script_manager = ScriptManager(args.template_path)

    if args.collect_path is None:  # submit mode
        if path.exists(ScriptManager.queue_file_path):  # there are some jobs still awaiting submission
            with open(ScriptManager.queue_file_path) as queue_file:
                input_paths = queue_file.read().splitlines()
            os.remove(ScriptManager.queue_file_path)  # remove the file to avoid reading it again
        else:
            input_paths, placeholders = script_manager.process_template()
        ScriptManager.submit_inputs(input_paths, submit_command)
    else:  # collect results mode
        collector = {}
        if resubmit_failed:
            input_paths, placeholders = script_manager.process_template(collector, result_regex, submit_command)
        else:
            input_paths, placeholders = script_manager.process_template(collector, result_regex)
        placeholder_names = [x.name for x in placeholders] + ["energy"]  # table headers are placeholder names, last column is named energy
        ScriptManager.print_results(collector, placeholder_names, args.collect_path)


main()
